<script>
  const car = document.getElementById("car");
  const scoreText = document.getElementById("score");
  const timeText = document.getElementById("time");
  const metaBar = document.getElementById("metaBar");
  const metaProgress = document.getElementById("metaProgress");
  const banderita = document.getElementById("banderita");
  const gameOverDiv = document.getElementById("game-over");
  const finalScore = document.getElementById("final-score");
  const finalTime = document.getElementById("final-time");
  const restartBtn = document.getElementById("restart-btn");
  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");
  const gameDiv = document.getElementById("game");

  // Carriles fijos
  const lanes = [30, 100, 170, 240];
  let currentLane = 1; // empieza en el segundo carril

  let score = 0, startTime = 0, elapsedTime = 0;
  let gameInterval, enemyInterval, roadInterval;
  let gameRunning = false;
  let enemySpawnSpeed = 1200;
  let bestScore = localStorage.getItem("mejorPuntuacion") || 0;
  const enemyImages = ['enemigo1.png','enemigo2.png','enemigo3.png'];

  // Para manejar el enemigo que chocó y detenerlo
  let stoppedEnemy = null;

  function updateCarPosition() {
    car.style.left = lanes[currentLane] + "px";
  }

  function moveLeft() {
    if (currentLane > 0) {
      currentLane--;
      updateCarPosition();
    }
  }

  function moveRight() {
    if (currentLane < lanes.length - 1) {
      currentLane++;
      updateCarPosition();
    }
  }

  document.addEventListener("keydown", e => {
    if (!gameRunning) startGame();
    if (e.key === "ArrowLeft") moveLeft();
    if (e.key === "ArrowRight") moveRight();
  });

  leftBtn.addEventListener("click", () => {
    if (!gameRunning) startGame();
    moveLeft();
  });

  rightBtn.addEventListener("click", () => {
    if (!gameRunning) startGame();
    moveRight();
  });

  function createEnemy() {
    if (!gameRunning) return;
    const e = document.createElement("div");
    e.classList.add("enemy");
    const i = Math.floor(Math.random() * enemyImages.length);
    const img = enemyImages[i];
    e.style.backgroundImage = `url('${img}')`;
    if (i === 2) e.classList.add("enemy3");
    e.style.left = lanes[Math.floor(Math.random() * lanes.length)] + "px";
    gameDiv.appendChild(e);
    // Animar bajada manual para poder pausar
    let start = null;
    const duration = 3000;
    function animateEnemy(timestamp) {
      if (!start) start = timestamp;
      let progress = timestamp - start;
      let percent = progress / duration;
      if (percent > 1) percent = 1;
      e.style.top = (-130 + (670 * percent)) + "px"; // de -130 a 540 (670px recorrido)
      if (percent < 1 && gameRunning && stoppedEnemy !== e) {
        requestAnimationFrame(animateEnemy);
      } else if (percent >=1) {
        e.remove();
      }
    }
    requestAnimationFrame(animateEnemy);
  }

  function createRoadLine() {
    if (!gameRunning) return;
    const l = document.createElement("div");
    l.classList.add("road-line");
    gameDiv.appendChild(l);
    setTimeout(() => l.remove(), 1000);
  }

  // Colisión precisa - solo cuando las cajas se toquen
  function detectCollision(a, b) {
    const A = a.getBoundingClientRect(), B = b.getBoundingClientRect();
    return (
      A.bottom > B.top &&
      A.top < B.bottom &&
      A.right > B.left &&
      A.left < B.right
    );
  }

  function updateDifficulty() {
    if (score % 200 === 0 && enemySpawnSpeed > 400) {
      enemySpawnSpeed -= 100;
      clearInterval(enemyInterval);
      enemyInterval = setInterval(createEnemy, enemySpawnSpeed);
    }
  }

  function checkMetaByTime() {
    let progress = (elapsedTime % 30) / 30 * 100;
    metaBar.style.display = "block";
    metaProgress.style.width = progress + "%";
    if (elapsedTime % 30 === 0 && elapsedTime !== 0) {
      banderita.style.display = "block";
      setTimeout(() => banderita.style.display = "none", 1500);
    }
  }

  function gameLoop() {
    if (!gameRunning) return;
    score++;
    scoreText.textContent = "Score: " + score;
    elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    timeText.textContent = "Time: " + elapsedTime + "s";
    updateDifficulty();
    checkMetaByTime();

    // Chequear colisiones con enemigos que siguen moviendose
    if (!stoppedEnemy) { // si no hay choque previo
      const enemies = document.querySelectorAll(".enemy");
      for (let e of enemies) {
        if (detectCollision(e, car)) {
          endGame(e);
          break;
        }
      }
    }
  }

  function startGame() {
    if (gameRunning) return;
    gameRunning = true;
    score = 0;
    elapsedTime = 0;
    enemySpawnSpeed = 1200;
    startTime = Date.now();
    currentLane = 1;
    updateCarPosition();
    gameOverDiv.style.display = "none";
    stoppedEnemy = null;
    document.querySelectorAll(".enemy,.road-line").forEach(x => x.remove());
    gameInterval = setInterval(gameLoop, 20);
    enemyInterval = setInterval(createEnemy, enemySpawnSpeed);
    roadInterval = setInterval(createRoadLine, 200);
  }

  function endGame(enemyHit) {
    gameRunning = false;
    clearInterval(gameInterval);
    clearInterval(enemyInterval);
    clearInterval(roadInterval);

    // Detener el enemigo y el carro en el choque
    stoppedEnemy = enemyHit;
    if (stoppedEnemy) {
      stoppedEnemy.style.animationPlayState = 'paused';
    }
    car.style.transition = 'none'; // quitar transición para efecto detenido

    let mensaje = `Puntuación: ${score}<br>Tiempo: ${elapsedTime}s`;
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem("mejorPuntuacion", bestScore);
      mensaje += `<br><strong>🎉 ¡Nuevo récord!</strong>`;
    } else {
      mensaje += `<br>🏆 Récord: ${bestScore}`;
    }
    finalScore.innerHTML = mensaje;
    gameOverDiv.style.display = "block";
  }

  restartBtn.addEventListener("click", () => {
    car.style.transition = 'left 0.1s ease-in-out'; // restaurar transición
    startGame();
  });
</script>
</body>
</html>
